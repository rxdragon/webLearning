# TCP/UDP协议

**TCP**是一种面向来连接的、可靠的、基于字节流的传输层通信协议。在计算机网络的OSI模型中，它完成第四层传输层所指定的功能。

- **面向连接**
- **仅支持单播**传输
- 面向**字节流**
- 可靠**传输**
- 提供**全双工**通信

**UDP**是一种简单的面向数据报、面向无连接、不可靠的通信协议，位于OSI模型的传输层。在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。

- 面向**无连接**
- **不可靠**传输
- 提供**单播、多播和广播**
- 面向**报文**

# TCP如何保证数据传输

- 检验和
- 序列号/确认应答
- 超时重传
- 最大消息长度
- 滑动窗口控制
- 拥塞控制

# GET/POST的本质区别

**get请求**的特点：

1.GET请求能够**被缓存**

2.GET请求**会保存**在浏览器的**浏览记录**中

3.以GET请求的URL**能够保存为浏览器书签**

4.get传送的**数据量较小**，不能大于2KB。

5.GET请求**主要用以获取数据**

**post请求**的特点：

1.POST请求**不能被缓存**下来

2.POST请求**不会保存**在浏览器浏览记录中

3.以POST请求的URL**无法保存为浏览器书签**

4.post传送的**数据量较大**，一般被默认为不受限制

GET/POST的最大区别是**GET请求**有**幂等性**，但是**POST请求没有**。什么是幂等性呢？我们知道使用**GET方法**请求**同样的接口**，**返回来的数据**是**不会改变**的，但是对于**POST请求**，实现一些**增删改查的操作**的时候**可能会发生重复提交**的问题。

也就是说我们如果**使用GET请求**做**增删改查**的时候，遇到网络不好**可能会多次操作**，**造成数据库的混乱**，这是一个很严重的问题，但是使用POST就不会有这种情况。

# http2.0

SPDY对当前的HTTP协议有4个改进：

- 多路复用请求；
  - SPDY在单个连接之上增加了一个帧层，用以多路复用多个并发流
  - 在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中：
    - **同域名下所有通信都在单个连接上完成**。
    - 单个连接可以承载任意数量的双向数据流。
    - 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。
  - 性能提升：
    - **同个域名只需要占用一个 TCP 连接**，消除了因多个 TCP 连接而带来的延时和内存消耗。
    - 单个连接上可以并行交错的请求和响应，之间互不干扰。

- 对请求划分优先级；

- 压缩HTTP头；

- 服务器推送流（即Server Push技术）；

# http缓存控制

![image-20210313143715591](https://cdn.jsdelivr.net/gh/rxdragon/webLearning/img/image-20210313143715591.png)

# http状态码

- ```
  1XX：信息状态码
  ```

  - `100 Continue` 继续，一般在发送`post`请求时，已发送了`http header`之后服务端将返回此信息，表示确认，之后发送具体参数信息

- ```
  2XX：成功状态码
  ```

  - `200 OK` 正常返回信息
  - `201 Created` 请求成功并且服务器创建了新的资源
  - `202 Accepted` 服务器已接受请求，但尚未处理

- ```
  3XX：重定向
  ```

  - `301 Moved Permanently` 请求的网页已永久移动到新位置。
  - `302 Found` 临时性重定向。
  - `303 See Other` 临时性重定向，且总是使用 `GET` 请求新的 `URI`。
  - `304 Not Modified` 自从上次请求后，请求的网页未修改过。

- ```
  4XX：客户端错误
  ```

  - `400 Bad Request` 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
  - `401 Unauthorized` 请求未授权。
  - `403 Forbidden` 禁止访问。
  - `404 Not Found` 找不到如何与 `URI` 相匹配的资源。

- ```
  5XX:服务器错误
  ```

  - `500 Internal Server Error` 最常见的服务器端错误。
  - `503 Service Unavailable` 服务器端暂时无法处理请求（可能是过载或维护）。

# HTTP与HTTPS的区别

- HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。
- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

# https握手

- 首先客户端发起请求到服务端，服务端处理后发送一个公钥给客户端
- 客户端进行验证公钥，看公钥是否有效和是否过期
- 客户端验证通过会产生随机值key，然后用公钥进行加密回传给服务端
- 服务端用私钥解密后获得客户端的随机值key
- 利用随机值key加密数据后传输给客户端
- 客户端利用key值进行解密数据
- 客户端获取真正的数据

# 断点续传和妙传

**简述原理**

断点续传说白了就是将一个文件按照一定的规则人为的分割成多个小文件，然后客户端每次只上传一个小文件（当然我们也可以利用多线程技术每次上传多个小文件），服务器接收到上传过来的小文件后根据一定的规则来组合这些小文件。如果在上传过程中出现网络中断等意外情况，下次再次上传时可以从已经上传的部分继续上传，而不是重新上传。

**详细讲解**

从 HTTP1.1 协议开始就已经支出获取文件的部分内容，断点续传技术就是利用 HTTP1.1 协议的这个特点在 Header 里添加两个参数来实现的。这两个参数分别客户端请求时发送的 Range 和服务器返回信息时返回的 Content-Range - Range，Range 用于指定第一个字节和最后一个字节的位置，格式如下：

Range:(unit=first byte pos)-[last byte pos]

Range 常用的格式有如下几种情况：

- Range:bytes=0-1024 ，表示传输的是从开头到第1024字节的内容；
- Range:bytes=1025-2048 ，表示传输的是从第1025到2048字节范围的内容；
- Range:bytes=-2000 ，表示传输的是最后2000字节的内容；
- Range:bytes=1024- ，表示传输的是从第1024字节开始到文件结束部分的内容；
- Range:bytes=0-0,-1 表示传输的是第一个和最后一个字节 ；
- Range:bytes=1024-2048,2049-3096,3097-4096 ，表示传输的是多个字节范围。

Content-Range 用于响应带有 Range 的请求。服务器会将 Content-Range 添加在响应的头部，格式如下：

Content-Range:bytes(unit first byte pos)-[last byte pos]/[entity length]

常见的格式内容如下：Content-Range:bytes 2048-4096/10240

这里边 2048-4096 表示当前发送的数据范围， 10240 表示文件总大小。

这里我顺便说一下，如果在客户端请求报文头中，对 Range 填入了错误的范围值，服务器会返回 416 状态码。416 状态码表示服务器无法处理所请求的数据区间，常见的情况是请求的数据区间不在文件范围之内，也就是说，Range 值，从语法上来说是没问题的，但从语义上来说却没有意义。

**注意：**

当使用断点续传的方式上传下载软件时 HTTP 响应头将会变为:

HTTP/1.1 206 Partial Content

当然光有 Range 和 Content-Range 还是不够的，我们还要知道服务端是否支持断点续传，只需要从如下两方面判断即可：

判断服务端是否只 HTTP/1.1 及以上版本，如果是则支持断点续传，如果不是则不支持服务端返回响应的头部是否包含 Access-Ranges ，且参数内容是 bytes 符合以上两个条件即可判定位支持断点续传。

**校验**

这里的校验主要针对断点续传下载来说的。当服务器端的文件发生改变时，客户端再次向服务端发送断点续传请求时，数据肯定就会发生错误。这时我们可以利用 Last-Modified 来标识最后的修改时间，这样就可以判断服务器上的文件是否发生改变。和 Last-Modified 具有同样功能的还有 if-Modified-Since,它俩的不同点是 Last-Modified 由服务器发送给客户端，而 if-Modified-Since 是由客户端发出， if-Modified-Since 将先前服务器发送给客户端的 Last-Modified 发送给服务器，服务器进行最后修改时间验证后，来告知客户端是否需要重新从服务器端获取新内容。客户端判断是否需要更新，只需要判断服务器返回的状态码即可，206 代表不需要重新获取接着下载就行，200代表需要重新获取。 但是 Last-Modified 和 if-Modified-Since 存在一些问题：

某些文件只是修改了修改时间而内容却没变，这时我们并不希望客户端重新缓存这些文件；

某些文件修改频繁，有时一秒要修改十几次，但是 if-Modified-Since 是秒级的，无法判断比秒更小的级别； 部分服务器无法获得精确的修改时间。 要解决上述问题我们就需要用到 Etag ，只需将相关标记（例如文件版本号等）放在引号内即可。

当使用校验的时候我们不需要手动实现验证，只需要利用 if-Range 结合 Last-Modified 或者 Etage 来判断是否发生改变，如果没有发生改变服务器将向客户端发送剩余的部分，否则发送全部。

注意：If-Range 必须与 Range 配套使用。缺少其中任意一个另一个都会被忽略。

**秒传**

**原理**

秒传利文件的MD5，首先将文件的MD5发送个服务器，服务器传输过来的MD5判断服务器上是否存在相同类型的文件，如果存在就将文件复制一份，而不是本地上传。这样就是先的秒传功能。

**MD5**

秒传涉及到了MD5，那么什么MD5呢？MD5的英文全称是 **Message-Digest Algorith 5** ,是计算机广泛使用的算法之一。 MD5 会为文件产生唯一的“指纹”，任何改动都会改变文件指纹。它以 512位分组来处理信息，每个分组又被分为16个32位分组，经过处理后输出4个32位分组，最后将输出的4个32位分组进行级联生成128位散列值。

MD5的具有压缩性、易计算、抗修改、弱抗碰撞和强抗碰撞。下面我们一一来讲解：

- 压缩性：任意长度数据，生成的MD5值长度是固定的；
- 易计算：可以很方便的从原始数据计算出MD5；
- 抗修改：对原始数据的任何修改，都会改变MD5；
- 弱抗碰撞和强抗碰撞：很难找到具有相同MD5的数据。

破解谣言：有人说网盘能秒传证明数据在网盘服务器是不加密的，有数据库查看权限的人都可以看，所以私密文件最好在本地磁盘加密后再上传到网盘中。这句话是错误的，正规的网盘服务器只是验证了文件的MD5码，文件还是加密存放的。

